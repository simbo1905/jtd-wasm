/// Top-level composition: walks a CompiledSchema AST and produces
/// a complete Python validation module by dispatching to per-node emitters.
use super::context::EmitContext;
use super::writer::{escape_py, CodeWriter};
use crate::ast::{CompiledSchema, Node, TypeKeyword};
use std::collections::BTreeMap;

/// Emit a complete Python 3.13+ module from a compiled schema.
pub fn emit(schema: &CompiledSchema) -> String {
    let mut w = CodeWriter::new();

    w.line("# fmt: off");
    w.line("# Generated by jtd-codegen (https://github.com/simbo1905/jtd-wasm)");
    w.line("# Do not edit manually.");

    if needs_timestamp(&schema.root, &schema.definitions) {
        w.line("import re");
        w.line("from datetime import datetime");
        w.line("");
        emit_timestamp_helper(&mut w);
    }

    w.line("");

    // Emit one function per definition
    for (name, node) in &schema.definitions {
        let fn_name = def_fn_name(name);
        w.open(&format!("def {fn_name}(v, e, p, sp)"));
        let ctx = EmitContext::definition();
        if is_no_op(node) {
            w.line("pass");
        } else {
            emit_node(&mut w, node, &ctx, None);
        }
        w.dedent();
        w.line("");
    }

    // Emit the exported validate() entry point
    w.open("def validate(instance)");
    w.line("e = []");
    let root_ctx = EmitContext::root();
    emit_node(&mut w, &schema.root, &root_ctx, None);
    w.line("return e");
    w.dedent();
    w.line("# fmt: on");

    w.finish()
}

/// Sanitize a definition name into a valid Python function name.
fn def_fn_name(name: &str) -> String {
    let safe: String = name
        .chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect();
    format!("validate_{safe}")
}

/// Check if an AST node produces no validation output.
fn is_no_op(node: &Node) -> bool {
    match node {
        Node::Empty => true,
        Node::Nullable { inner } => matches!(inner.as_ref(), Node::Empty),
        _ => false,
    }
}

fn needs_timestamp(root: &Node, defs: &BTreeMap<String, Node>) -> bool {
    node_uses_timestamp(root) || defs.values().any(node_uses_timestamp)
}

fn node_uses_timestamp(node: &Node) -> bool {
    match node {
        Node::Type { type_kw } => *type_kw == TypeKeyword::Timestamp,
        Node::Nullable { inner } => node_uses_timestamp(inner),
        Node::Elements { schema } | Node::Values { schema } => node_uses_timestamp(schema),
        Node::Properties {
            required, optional, ..
        } => required
            .values()
            .chain(optional.values())
            .any(node_uses_timestamp),
        Node::Discriminator { mapping, .. } => mapping.values().any(node_uses_timestamp),
        _ => false,
    }
}

fn emit_timestamp_helper(w: &mut CodeWriter) {
    w.line(r#"_TS_RE = re.compile(r'^\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:(\d{2}|60)(\.\d+)?([Zz]|[+-]\d{2}:\d{2})$')"#);
    w.line("");
    w.open("def _is_rfc3339(s)");
    w.open("if not isinstance(s, str) or not _TS_RE.match(s)");
    w.line("return False");
    w.dedent();
    w.open("try");
    w.line("n = s.replace(\"t\", \"T\", 1)");
    w.open("if n.endswith(\"z\")");
    w.line("n = n[:-1] + \"Z\"");
    w.dedent();
    w.line("n = n.replace(\":60\", \":59\", 1)");
    w.line("datetime.fromisoformat(n)");
    w.line("return True");
    w.close_open("except (ValueError, OverflowError)");
    w.line("return False");
    w.dedent();
    w.dedent();
    w.line("");
}

/// Recursively emit validation code for one AST node.
fn emit_node(w: &mut CodeWriter, node: &Node, ctx: &EmitContext, discrim_tag: Option<&str>) {
    match node {
        Node::Empty => {}

        Node::Type { type_kw } => emit_type(w, ctx, *type_kw),

        Node::Enum { values } => {
            let items: Vec<String> = values
                .iter()
                .map(|v| format!("\"{}\"", escape_py(v)))
                .collect();
            let set_literal = format!("{{{}}}", items.join(", "));
            w.open(&format!(
                "if not isinstance({val}, str) or {val} not in {set_literal}",
                val = ctx.val,
            ));
            w.line(&ctx.push_error("/enum"));
            w.dedent();
        }

        Node::Ref { name } => {
            let fn_name = def_fn_name(name);
            let escaped = escape_py(name);
            w.line(&format!(
                "{fn_name}({}, {}, {}, \"/definitions/{escaped}\")",
                ctx.val, ctx.err, ctx.ip
            ));
        }

        Node::Nullable { inner } => {
            if matches!(inner.as_ref(), Node::Empty) {
                return;
            }
            w.open(&format!("if {} is not None", ctx.val));
            emit_node(w, inner, ctx, None);
            w.dedent();
        }

        Node::Elements { schema } => {
            emit_elements(w, ctx, schema);
        }

        Node::Values { schema } => {
            emit_values(w, ctx, schema);
        }

        Node::Properties {
            required,
            optional,
            additional,
        } => {
            emit_properties(w, ctx, required, optional, *additional, discrim_tag);
        }

        Node::Discriminator { tag, mapping } => {
            emit_discriminator(w, ctx, tag, mapping);
        }
    }
}

/// Emit a type check.
fn emit_type(w: &mut CodeWriter, ctx: &EmitContext, type_kw: TypeKeyword) {
    let cond = type_condition(type_kw, &ctx.val);
    w.open(&format!("if {cond}"));
    w.line(&ctx.push_error("/type"));
    w.dedent();
}

/// Returns a Python expression that evaluates to `true` when `val`
/// does NOT satisfy the given type keyword.
fn type_condition(type_kw: TypeKeyword, val: &str) -> String {
    match type_kw {
        TypeKeyword::Boolean => {
            format!("not isinstance({val}, bool)")
        }
        TypeKeyword::String => {
            format!("not isinstance({val}, str)")
        }
        TypeKeyword::Timestamp => {
            format!("not _is_rfc3339({val})")
        }
        TypeKeyword::Float32 | TypeKeyword::Float64 => {
            format!("not isinstance({val}, (int, float)) or isinstance({val}, bool)")
        }
        TypeKeyword::Int8 => int_cond(val, -128, 127),
        TypeKeyword::Uint8 => int_cond(val, 0, 255),
        TypeKeyword::Int16 => int_cond(val, -32768, 32767),
        TypeKeyword::Uint16 => int_cond(val, 0, 65535),
        TypeKeyword::Int32 => int_cond(val, -2_147_483_648, 2_147_483_647),
        TypeKeyword::Uint32 => int_cond(val, 0, 4_294_967_295),
    }
}

fn int_cond(val: &str, min: i64, max: i64) -> String {
    format!(
        "not isinstance({val}, (int, float)) or isinstance({val}, bool) or {val} % 1 != 0 or {val} < {min} or {val} > {max}"
    )
}

/// Elements form: array type guard + loop with inner check.
fn emit_elements(w: &mut CodeWriter, ctx: &EmitContext, schema: &Node) {
    let err_stmt = ctx.push_error("/elements");
    w.open(&format!("if not isinstance({}, list)", ctx.val));
    w.line(&err_stmt);
    w.close_open("else");

    let idx = ctx.idx_var();
    w.open(&format!("for {idx} in range(len({}))", ctx.val));
    if is_no_op(schema) {
        w.line("pass");
    } else {
        let elem_ctx = ctx.element(&idx);
        emit_node(w, schema, &elem_ctx, None);
    }
    w.dedent(); // for
    w.dedent(); // else
}

/// Values form: object type guard + for-in loop with inner check.
fn emit_values(w: &mut CodeWriter, ctx: &EmitContext, schema: &Node) {
    let err_stmt = ctx.push_error("/values");
    w.open(&format!("if not isinstance({}, dict)", ctx.val));
    w.line(&err_stmt);
    w.close_open("else");

    let key_var = ctx.key_var();
    w.open(&format!("for {} in {}", key_var, ctx.val));
    if is_no_op(schema) {
        w.line("pass");
    } else {
        let entry_ctx = ctx.values_entry(&key_var);
        emit_node(w, schema, &entry_ctx, None);
    }
    w.dedent(); // for
    w.dedent(); // else
}

/// Properties form: object guard, required checks, optional checks,
/// additional-property rejection.
fn emit_properties(
    w: &mut CodeWriter,
    ctx: &EmitContext,
    required: &BTreeMap<String, Node>,
    optional: &BTreeMap<String, Node>,
    additional: bool,
    discrim_tag: Option<&str>,
) {
    // Object type guard -- error points to the form keyword
    let guard_sp = if !required.is_empty() {
        "/properties"
    } else {
        "/optionalProperties"
    };
    w.open(&format!("if not isinstance({}, dict)", ctx.val));
    w.line(&ctx.push_error(guard_sp));
    w.close_open("else");

    let mut has_content = false;

    // Required properties
    for (key, node) in required {
        has_content = true;
        let escaped = escape_py(key);
        w.open(&format!("if \"{}\" not in {}", escaped, ctx.val));
        w.line(&ctx.push_error(&format!("/properties/{escaped}")));
        if !is_no_op(node) {
            w.close_open("else");
            let child_ctx = ctx.required_prop(key);
            emit_node(w, node, &child_ctx, None);
        }
        w.dedent();
    }

    // Optional properties -- skip if value schema is no-op
    for (key, node) in optional {
        if !is_no_op(node) {
            has_content = true;
            let escaped = escape_py(key);
            w.open(&format!("if \"{}\" in {}", escaped, ctx.val));
            let child_ctx = ctx.optional_prop(key);
            emit_node(w, node, &child_ctx, None);
            w.dedent();
        }
    }

    // Additional properties rejection
    if !additional {
        has_content = true;
        let k_var = "k";
        w.open(&format!("for {k_var} in {}", ctx.val));

        let mut known: Vec<&str> = Vec::new();
        if let Some(tag) = discrim_tag {
            known.push(tag);
        }
        for key in required.keys() {
            known.push(key);
        }
        for key in optional.keys() {
            known.push(key);
        }

        if known.is_empty() {
            w.line(&ctx.push_error_dynamic(&format!("\"/\" + {k_var}"), ""));
        } else {
            let conds: Vec<String> = known
                .iter()
                .map(|k| format!("{k_var} != \"{}\"", escape_py(k)))
                .collect();
            w.open(&format!("if {}", conds.join(" and ")));
            w.line(&ctx.push_error_dynamic(&format!("\"/\" + {k_var}"), ""));
            w.dedent();
        }

        w.dedent(); // for
    }

    if !has_content {
        w.line("pass");
    }

    w.dedent(); // else
}

/// Discriminator form: 5-step check dispatching to variant Properties via emit_node.
fn emit_discriminator(
    w: &mut CodeWriter,
    ctx: &EmitContext,
    tag: &str,
    mapping: &BTreeMap<String, Node>,
) {
    let escaped_tag = escape_py(tag);

    // Step 1: not an object
    w.open(&format!("if not isinstance({}, dict)", ctx.val));
    w.line(&ctx.push_error("/discriminator"));

    // Step 2: tag missing
    w.close_open(&format!("elif \"{}\" not in {}", escaped_tag, ctx.val));
    w.line(&ctx.push_error("/discriminator"));

    // Step 3: tag not string
    w.close_open(&format!(
        "elif not isinstance({}[\"{}\"], str)",
        ctx.val, escaped_tag
    ));
    w.line(&ctx.push_error_at(&format!("/{escaped_tag}"), "/discriminator"));

    // Step 4: dispatch per variant
    for (variant_key, variant_node) in mapping {
        let escaped_variant = escape_py(variant_key);
        w.close_open(&format!(
            "elif {}[\"{}\"] == \"{}\"",
            ctx.val, escaped_tag, escaped_variant
        ));
        let variant_ctx = ctx.discrim_variant(variant_key);
        emit_node(w, variant_node, &variant_ctx, Some(tag));
    }

    // Step 5: unknown tag value
    w.close_open("else");
    w.line(&ctx.push_error_at(&format!("/{escaped_tag}"), "/mapping"));
    w.dedent();
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler;
    use serde_json::json;

    #[test]
    fn test_emit_empty_schema() {
        let schema = json!({});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("def validate(instance)"));
        assert!(code.contains("e = []"));
        assert!(code.contains("return e"));
        // No type checks for empty schema
        assert!(!code.contains("isinstance"));
    }

    #[test]
    fn test_emit_type_string() {
        let schema = json!({"type": "string"});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("not isinstance(instance, str)"));
    }

    #[test]
    fn test_emit_type_boolean() {
        let schema = json!({"type": "boolean"});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("not isinstance(instance, bool)"));
    }

    #[test]
    fn test_emit_type_uint8() {
        let schema = json!({"type": "uint8"});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("isinstance(instance, (int, float))"));
        assert!(code.contains("isinstance(instance, bool)"));
        assert!(code.contains("% 1 != 0"));
        assert!(code.contains("< 0"));
        assert!(code.contains("> 255"));
    }

    #[test]
    fn test_emit_type_float64() {
        let schema = json!({"type": "float64"});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(
            code.contains("not isinstance(instance, (int, float)) or isinstance(instance, bool)")
        );
    }

    #[test]
    fn test_emit_enum() {
        let schema = json!({"enum": ["a", "b", "c"]});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("not isinstance(instance, str)"));
        assert!(code.contains("{\"a\", \"b\", \"c\"}"));
    }

    #[test]
    fn test_emit_ref_generates_definition_function() {
        let schema = json!({
            "definitions": {"addr": {"type": "string"}},
            "ref": "addr"
        });
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        // Definition function
        assert!(code.contains("def validate_addr(v, e, p, sp)"));
        assert!(code.contains("not isinstance(v, str)"));
        // Root calls it
        assert!(code.contains("validate_addr(instance, e, \"\", \"/definitions/addr\")"));
    }

    #[test]
    fn test_emit_nullable() {
        let schema = json!({"type": "string", "nullable": true});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("if instance is not None"));
        assert!(code.contains("not isinstance(instance, str)"));
    }

    #[test]
    fn test_emit_nullable_empty_produces_nothing() {
        let schema = json!({"nullable": true});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(!code.contains("is not None"));
    }

    #[test]
    fn test_emit_elements() {
        let schema = json!({"elements": {"type": "string"}});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("not isinstance(instance, list)"));
        assert!(code.contains("for i in range(len(instance))"));
        assert!(code.contains("instance[i]"));
    }

    #[test]
    fn test_emit_values() {
        let schema = json!({"values": {"type": "string"}});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("not isinstance(instance, dict)"));
        assert!(code.contains("for k in instance"));
        assert!(code.contains("instance[k]"));
    }

    #[test]
    fn test_emit_properties() {
        let schema = json!({
            "properties": {
                "name": {"type": "string"},
                "age": {"type": "uint8"}
            },
            "optionalProperties": {
                "email": {"type": "string"}
            }
        });
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);

        // Object type guard
        assert!(code.contains("not isinstance(instance, dict)"));

        // Required property checks
        assert!(code.contains("\"name\" not in instance"));
        assert!(code.contains("\"age\" not in instance"));

        // Optional property check
        assert!(code.contains("\"email\" in instance"));

        // Additional properties
        assert!(code.contains("for k in instance"));
        assert!(code.contains("k != \"age\""));
        assert!(code.contains("k != \"name\""));
        assert!(code.contains("k != \"email\""));
    }

    #[test]
    fn test_emit_discriminator() {
        let schema = json!({
            "discriminator": "type",
            "mapping": {
                "cat": {"properties": {"meow": {"type": "boolean"}}},
                "dog": {"properties": {"bark": {"type": "boolean"}}}
            }
        });
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);

        // Step 1: object guard
        assert!(code.contains("not isinstance(instance, dict)"));
        // Step 2: tag missing
        assert!(code.contains("\"type\" not in instance"));
        // Step 3: tag not string
        assert!(code.contains("not isinstance(instance[\"type\"], str)"));
        // Step 4: variant dispatch
        assert!(code.contains("instance[\"type\"] == \"cat\""));
        assert!(code.contains("instance[\"type\"] == \"dog\""));
        // Step 5: unknown tag
        assert!(code.contains("/mapping"));
    }

    #[test]
    fn test_emit_timestamp_imports() {
        let schema = json!({"type": "timestamp"});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("import re"));
        assert!(code.contains("from datetime import datetime"));
        assert!(code.contains("_is_rfc3339"));
    }

    #[test]
    fn test_emit_no_timestamp_no_imports() {
        let schema = json!({"type": "string"});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(!code.contains("import re"));
        assert!(!code.contains("datetime"));
    }

    #[test]
    fn test_fmt_markers() {
        let schema = json!({});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.starts_with("# fmt: off\n"));
        assert!(code.contains("# fmt: on"));
    }
}
