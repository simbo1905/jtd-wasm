use super::types;
/// Top-level Rust code emitter. Generates a standalone Rust module
/// that validates serde_json::Value instances against a compiled JTD schema.
use crate::ast::{CompiledSchema, Node, TypeKeyword};
use crate::emit_js::CodeWriter;

/// Emit a complete Rust source file from a compiled schema.
pub fn emit(schema: &CompiledSchema) -> String {
    let mut w = CodeWriter::new();

    w.line("// Generated by jtd-codegen (https://github.com/simbo1905/jtd-wasm)");
    w.line("// This code is generated from a JSON Type Definition schema.");
    w.line("// Do not edit manually.");
    w.line("");
    w.line("use serde_json::Value;");
    w.line("");

    if needs_timestamp(&schema.root, &schema.definitions) {
        emit_timestamp_helper(&mut w);
    }

    for (name, node) in &schema.definitions {
        let fn_name = def_fn_name(name);
        w.open(&format!(
            "fn {fn_name}(v: &Value, e: &mut Vec<(String, String)>, p: &str, sp: &str)"
        ));
        emit_node(&mut w, node, "v", "p", "sp", "e", 0, None);
        w.close();
        w.line("");
    }

    w.open("pub fn validate(instance: &Value) -> Vec<(String, String)>");
    w.line("let mut e: Vec<(String, String)> = Vec::new();");
    w.line("let p = \"\";");
    w.line("let sp = \"\";");
    emit_node(
        &mut w,
        &schema.root,
        "instance",
        "p",
        "sp",
        "&mut e",
        0,
        None,
    );
    w.line("e");
    w.close();

    w.finish()
}

fn def_fn_name(name: &str) -> String {
    let safe: String = name
        .chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect();
    format!("validate_{safe}")
}

fn needs_timestamp(root: &Node, defs: &std::collections::BTreeMap<String, Node>) -> bool {
    node_uses_timestamp(root) || defs.values().any(node_uses_timestamp)
}

fn node_uses_timestamp(node: &Node) -> bool {
    match node {
        Node::Type { type_kw } => *type_kw == TypeKeyword::Timestamp,
        Node::Nullable { inner } => node_uses_timestamp(inner),
        Node::Elements { schema } | Node::Values { schema } => node_uses_timestamp(schema),
        Node::Properties {
            required, optional, ..
        } => required
            .values()
            .chain(optional.values())
            .any(node_uses_timestamp),
        Node::Discriminator { mapping, .. } => mapping.values().any(node_uses_timestamp),
        _ => false,
    }
}

fn emit_timestamp_helper(w: &mut CodeWriter) {
    w.open("fn is_rfc3339(s: &str) -> bool");
    w.line("use std::sync::OnceLock;");
    w.line("static RE: OnceLock<regex::Regex> = OnceLock::new();");
    w.line("let re = RE.get_or_init(|| regex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}[Tt]\\d{2}:\\d{2}:(\\d{2}|60)(\\.\\d+)?([Zz]|[+-]\\d{2}:\\d{2})$\").unwrap());");
    w.line("if !re.is_match(s) { return false; }");
    w.line("let normalized = s.replace(\":60\", \":59\");");
    w.line("chrono::DateTime::parse_from_rfc3339(&normalized).is_ok()");
    w.close();
    w.line("");
}

/// Helper: generate a push_error statement.
/// `err` is the error vec expression (may include `&mut ` prefix),
/// `ip_expr` builds the instancePath, `sp_expr` builds the schemaPath.
fn push_err(err: &str, ip_expr: &str, sp_expr: &str) -> String {
    let vec_name = err.strip_prefix("&mut ").unwrap_or(err);
    format!("{vec_name}.push(({ip_expr}, {sp_expr}));")
}

/// `ip` and `sp` are always Rust variable names of type `&str`.
/// To build "ip + /foo" we emit `format!("{{ip}}/foo")`.
fn ip_str(ip: &str) -> String {
    format!("{ip}.to_string()")
}

fn ip_with(ip: &str, suffix: &str) -> String {
    format!("format!(\"{{{}}}{}\")", ip, suffix)
}

fn sp_str(sp: &str) -> String {
    format!("{sp}.to_string()")
}

fn sp_with(sp: &str, suffix: &str) -> String {
    format!("format!(\"{{{}}}{}\")", sp, suffix)
}

#[allow(clippy::too_many_arguments)]
fn emit_node(
    w: &mut CodeWriter,
    node: &Node,
    val: &str,
    ip: &str,
    sp: &str,
    err: &str,
    depth: usize,
    discrim_tag: Option<&str>,
) {
    match node {
        Node::Empty => {}

        Node::Type { type_kw } => {
            let cond = types::type_condition(*type_kw, val);
            w.open(&format!("if {cond}"));
            w.line(&push_err(err, &ip_str(ip), &sp_with(sp, "/type")));
            w.close();
        }

        Node::Enum { values } => {
            let items: Vec<String> = values.iter().map(|v| format!("\"{}\"", v)).collect();
            let arr = items.join(", ");
            w.open(&format!(
                "if !{val}.as_str().map_or(false, |s| [{arr}].contains(&s))"
            ));
            w.line(&push_err(err, &ip_str(ip), &sp_with(sp, "/enum")));
            w.close();
        }

        Node::Ref { name } => {
            let fn_name = def_fn_name(name);
            // Borrow ip in case it's a String variable (e.g. ip_e0)
            w.line(&format!(
                "{fn_name}({val}, {err}, &{ip}, &format!(\"/definitions/{name}\"));"
            ));
        }

        Node::Nullable { inner } => {
            if matches!(inner.as_ref(), Node::Empty) {
                return;
            }
            w.open(&format!("if !{val}.is_null()"));
            emit_node(w, inner, val, ip, sp, err, depth, None);
            w.close();
        }

        Node::Elements { schema } => {
            let iv = idx_var(depth);
            w.open(&format!("if let Some(arr) = {val}.as_array()"));
            w.open(&format!("for ({iv}, elem) in arr.iter().enumerate()"));
            // Build child ip/sp variable names
            let child_ip = format!("ip_e{depth}");
            let child_sp = format!("sp_e{depth}");
            w.line(&format!("let {child_ip} = format!(\"{{{ip}}}/{{{iv}}}\");"));
            w.line(&format!("let {child_sp} = format!(\"{{{sp}}}/elements\");"));
            emit_node(
                w,
                schema,
                "elem",
                &child_ip,
                &child_sp,
                err,
                depth + 1,
                None,
            );
            w.close(); // for
            w.close_open("else");
            w.line(&push_err(err, &ip_str(ip), &sp_with(sp, "/elements")));
            w.close();
        }

        Node::Values { schema } => {
            let kv = key_var(depth);
            w.open(&format!("if let Some(obj) = {val}.as_object()"));
            w.open(&format!("for ({kv}, vv) in obj"));
            let child_ip = format!("ip_v{depth}");
            let child_sp = format!("sp_v{depth}");
            w.line(&format!("let {child_ip} = format!(\"{{{ip}}}/{{{kv}}}\");"));
            w.line(&format!("let {child_sp} = format!(\"{{{sp}}}/values\");"));
            emit_node(w, schema, "vv", &child_ip, &child_sp, err, depth + 1, None);
            w.close(); // for
            w.close_open("else");
            w.line(&push_err(err, &ip_str(ip), &sp_with(sp, "/values")));
            w.close();
        }

        Node::Properties {
            required,
            optional,
            additional,
        } => {
            let guard_suffix = if !required.is_empty() {
                "/properties"
            } else {
                "/optionalProperties"
            };
            w.open(&format!("if let Some(obj) = {val}.as_object()"));

            for (key, child_node) in required {
                let child_ip = format!("ip_p_{key}");
                let child_sp = format!("sp_p_{key}");
                w.open(&format!("if let Some(pv) = obj.get(\"{key}\")"));
                w.line(&format!("let {child_ip} = format!(\"{{{ip}}}/{key}\");"));
                w.line(&format!(
                    "let {child_sp} = format!(\"{{{sp}}}/properties/{key}\");"
                ));
                emit_node(w, child_node, "pv", &child_ip, &child_sp, err, depth, None);
                w.close_open("else");
                w.line(&push_err(
                    err,
                    &ip_str(ip),
                    &sp_with(sp, &format!("/properties/{key}")),
                ));
                w.close();
            }

            for (key, child_node) in optional {
                let child_ip = format!("ip_o_{key}");
                let child_sp = format!("sp_o_{key}");
                w.open(&format!("if let Some(pv) = obj.get(\"{key}\")"));
                w.line(&format!("let {child_ip} = format!(\"{{{ip}}}/{key}\");"));
                w.line(&format!(
                    "let {child_sp} = format!(\"{{{sp}}}/optionalProperties/{key}\");"
                ));
                emit_node(w, child_node, "pv", &child_ip, &child_sp, err, depth, None);
                w.close();
            }

            if !*additional {
                let kv = key_var(depth);
                w.open(&format!("for {kv} in obj.keys()"));
                let mut known: Vec<&str> = Vec::new();
                if let Some(tag) = discrim_tag {
                    known.push(tag);
                }
                for key in required.keys() {
                    known.push(key);
                }
                for key in optional.keys() {
                    known.push(key);
                }
                if known.is_empty() {
                    w.line(&push_err(
                        err,
                        &format!("format!(\"{{{ip}}}/{{{kv}}}\")"),
                        &sp_str(sp),
                    ));
                } else {
                    let conds: Vec<String> = known
                        .iter()
                        .map(|k| format!("{kv}.as_str() != \"{k}\""))
                        .collect();
                    w.open(&format!("if {}", conds.join(" && ")));
                    w.line(&push_err(
                        err,
                        &format!("format!(\"{{{ip}}}/{{{kv}}}\")"),
                        &sp_str(sp),
                    ));
                    w.close();
                }
                w.close(); // for
            }

            w.close_open("else");
            w.line(&push_err(err, &ip_str(ip), &sp_with(sp, guard_suffix)));
            w.close();
        }

        Node::Discriminator { tag, mapping } => {
            w.open(&format!("if let Some(obj) = {val}.as_object()"));
            w.open(&format!("if let Some(tag_val) = obj.get(\"{tag}\")"));
            w.open("if let Some(tag_str) = tag_val.as_str()");
            w.open("match tag_str");

            for (variant_key, variant_node) in mapping {
                let vsp = format!("sp_m_{variant_key}");
                w.open(&format!("\"{variant_key}\" =>"));
                w.line(&format!(
                    "let {vsp} = format!(\"{{{sp}}}/mapping/{variant_key}\");"
                ));
                emit_node(w, variant_node, val, ip, &vsp, err, depth, Some(tag));
                w.close();
            }

            w.open("_ =>");
            w.line(&push_err(
                err,
                &ip_with(ip, &format!("/{tag}")),
                &sp_with(sp, "/mapping"),
            ));
            w.close(); // _
            w.close(); // match

            w.close_open("else");
            w.line(&push_err(
                err,
                &ip_with(ip, &format!("/{tag}")),
                &sp_with(sp, "/discriminator"),
            ));
            w.close(); // tag not string

            w.close_open("else");
            w.line(&push_err(err, &ip_str(ip), &sp_with(sp, "/discriminator")));
            w.close(); // tag missing

            w.close_open("else");
            w.line(&push_err(err, &ip_str(ip), &sp_with(sp, "/discriminator")));
            w.close(); // not object
        }
    }
}

fn idx_var(depth: usize) -> String {
    if depth == 0 {
        "i".into()
    } else {
        format!("i{depth}")
    }
}

fn key_var(depth: usize) -> String {
    if depth == 0 {
        "k".into()
    } else {
        format!("k{depth}")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler;
    use serde_json::json;

    #[test]
    fn test_emit_empty_schema() {
        let schema = json!({});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("pub fn validate("));
        assert!(code.contains("Vec::new()"));
        assert!(!code.contains("is_boolean"));
    }

    #[test]
    fn test_emit_type_string() {
        let schema = json!({"type": "string"});
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("is_string()"));
    }

    #[test]
    fn test_emit_ref() {
        let schema = json!({
            "definitions": {"addr": {"type": "string"}},
            "ref": "addr"
        });
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("fn validate_addr("));
        assert!(code.contains("/definitions/addr"));
    }

    #[test]
    fn test_emit_properties() {
        let schema = json!({
            "properties": {"name": {"type": "string"}}
        });
        let compiled = compiler::compile(&schema).unwrap();
        let code = emit(&compiled);
        assert!(code.contains("obj.get(\"name\")"));
        assert!(code.contains("/properties/name"));
    }
}
