use super::context::EmitContext;
use super::writer::{escape_lua, CodeWriter};
use crate::ast::{CompiledSchema, Node, TypeKeyword};
use std::collections::BTreeMap;

/// Emit a complete Lua module from a compiled schema.
pub fn emit(schema: &CompiledSchema) -> String {
    let mut w = CodeWriter::new();

    w.line("-- Generated by jtd-codegen (https://github.com/simbo1905/jtd-wasm)");
    w.line("-- This code is generated from a JSON Type Definition schema.");
    w.line("-- Do not edit manually.");
    w.line("");
    w.line("local M = {}");
    w.line("-- Generated validators require dkjson for null sentinel handling.");
    w.line("-- Lua 5.1 cannot distinguish JSON null from table absence; dkjson.null");
    w.line("-- provides a reliable sentinel that preserves JTD validation semantics.");
    w.line("-- Future enhancement: Add --lua-null-sentinel <name> CLI flag to make");
    w.line("-- this configurable for users who prefer other JSON libraries.");
    w.line("local dkjson = require(\"dkjson\")");
    w.line("");

    // Helper: is_integer
    w.open("local function is_integer(v)");
    w.line("return type(v) == \"number\" and v == math.floor(v)");
    w.close("end");

    w.open("local function is_array(v)");
    w.line("if v == dkjson.null then return false end");
    w.line("if type(v) ~= \"table\" then return false end");
    w.line("local mt = getmetatable(v)");
    w.line("if mt and mt.__jsontype == \"object\" then return false end");
    w.line("if mt and mt.__jsontype == \"array\" then return true end");
    w.line("if #v > 0 then return true end");
    w.line("return next(v) == nil");
    w.close("end");

    w.open("local function is_object(v)");
    w.line("if v == dkjson.null then return false end");
    w.line("if type(v) ~= \"table\" then return false end");
    w.line("local mt = getmetatable(v)");
    w.line("if mt and mt.__jsontype == \"array\" then return false end");
    w.line("if mt and mt.__jsontype == \"object\" then return true end");
    w.line("if #v > 0 then return false end");
    w.line("return true");
    w.close("end");

    w.line("");

    if needs_timestamp(&schema.root, &schema.definitions) {
        emit_timestamp_helper(&mut w);
    }

    // Definitions
    for (name, node) in &schema.definitions {
        let fn_name = def_fn_name(name);
        w.open(&format!("local function {fn_name}(v, e, p, sp)"));
        let ctx = EmitContext::definition();
        emit_node(&mut w, node, &ctx, None);
        w.close("end");
        w.line("");
    }

    // Root validate function
    w.open("function M.validate(instance)");
    w.line("local e = {}");
    let ctx = EmitContext::root();
    emit_node(&mut w, &schema.root, &ctx, None);
    w.line("return e");
    w.close("end");

    w.line("");
    w.line("return M");

    w.finish()
}

fn def_fn_name(name: &str) -> String {
    let safe: String = name
        .chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect();
    format!("validate_{safe}")
}

fn needs_timestamp(root: &Node, defs: &BTreeMap<String, Node>) -> bool {
    node_uses_timestamp(root) || defs.values().any(node_uses_timestamp)
}

fn node_uses_timestamp(node: &Node) -> bool {
    match node {
        Node::Type { type_kw } => *type_kw == TypeKeyword::Timestamp,
        Node::Nullable { inner } => node_uses_timestamp(inner),
        Node::Elements { schema } | Node::Values { schema } => node_uses_timestamp(schema),
        Node::Properties {
            required, optional, ..
        } => required
            .values()
            .chain(optional.values())
            .any(node_uses_timestamp),
        Node::Discriminator { mapping, .. } => mapping.values().any(node_uses_timestamp),
        _ => false,
    }
}

fn emit_timestamp_helper(w: &mut CodeWriter) {
    w.open("local function is_rfc3339(s)");
    w.line("if type(s) ~= \"string\" then return false end");
    w.line("-- Pattern: YYYY-MM-DDThh:mm:ss[.frac](Z|+/-hh:mm)");
    // Lua patterns are limited. We do a loose check for structure.
    // 4 digits - 2 digits - 2 digits T 2 digits : 2 digits : 2 digits
    w.line("local y, m, d, t, h, min, s2, rest = s:match(\"^([0-9][0-9][0-9][0-9])%-([0-9][0-9])%-([0-9][0-9])([Tt])([0-9][0-9]):([0-9][0-9]):([0-9][0-9])(.*)$\")");
    w.line("if not y then return false end");
    w.line("-- Validate component ranges");
    w.line("local mn, dn, hn, minn, sn = tonumber(m), tonumber(d), tonumber(h), tonumber(min), tonumber(s2)");
    w.line("if mn < 1 or mn > 12 then return false end");
    w.line("if dn < 1 or dn > 31 then return false end");
    w.line("if hn > 23 then return false end");
    w.line("if minn > 59 then return false end");
    w.line("if sn > 60 then return false end"); // RFC 3339 allows 60 for leap seconds
    w.line("-- Optional fraction");
    w.line("local off = rest");
    w.open("if rest:sub(1, 1) == \".\" then");
    w.line("local frac_end = rest:find(\"[^0-9]\", 2)");
    w.open("if not frac_end then");
    w.line("-- Just fraction, no offset?");
    w.line("return false");
    w.close("else");
    w.line("off = rest:sub(frac_end)");
    w.close("end");
    w.close("end");

    w.line("-- Offset: Z or z or +/-hh:mm");
    w.line("if off == \"Z\" or off == \"z\" then return true end");
    w.line("local oh, om = off:match(\"^[+-]([0-9][0-9]):([0-9][0-9])$\")");
    w.open("if oh then");
    w.line("local ohn, omn = tonumber(oh), tonumber(om)");
    w.line("if ohn > 23 or omn > 59 then return false end");
    w.line("return true");
    w.close("end");
    w.line("return false");
    w.close("end");
    w.line("");
}

fn emit_node(w: &mut CodeWriter, node: &Node, ctx: &EmitContext, discrim_tag: Option<&str>) {
    match node {
        Node::Empty => {}

        Node::Type { type_kw } => emit_type(w, ctx, *type_kw),

        Node::Enum { values } => {
            let conds: Vec<String> = values
                .iter()
                .map(|v| format!("{} ~= \"{}\"", ctx.val, escape_lua(v)))
                .collect();
            w.open(&format!("if {} then", conds.join(" and ")));
            w.line(&ctx.push_error("/enum"));
            w.close("end");
        }

        Node::Ref { name } => {
            let fn_name = def_fn_name(name);
            w.line(&format!(
                "{}({}, {}, {}, \"/definitions/{}\")",
                fn_name, ctx.val, ctx.err, ctx.ip, name
            ));
        }

        Node::Nullable { inner } => {
            if matches!(inner.as_ref(), Node::Empty) {
                return;
            }
            // Check for dkjson.null AND nil (just in case)
            w.open(&format!(
                "if {} ~= nil and {} ~= dkjson.null then",
                ctx.val, ctx.val
            ));
            emit_node(w, inner, ctx, None);
            w.close("end");
        }

        Node::Elements { schema } => {
            let idx = ctx.idx_var();
            w.open(&format!("if is_array({}) then", ctx.val));
            // In Lua, it's hard to distinguish array vs object strictly.
            // We assume table is valid.
            w.open(&format!("for {}, elem in ipairs({}) do", idx, ctx.val));
            let child_ctx = ctx.element(&idx);
            // Redefine child val to be 'elem' for cleaner code, or use ctx val
            let mut inner_ctx = child_ctx.clone();
            inner_ctx.val = "elem".to_string(); // Optimization: use loop var
            emit_node(w, schema, &inner_ctx, None);
            w.close("end");
            w.close_open("else");
            w.line(&ctx.push_error("/elements"));
            w.close("end");
        }

        Node::Values { schema } => {
            let key = ctx.key_var();
            w.open(&format!("if is_object({}) then", ctx.val));
            w.open(&format!("for {}, val in pairs({}) do", key, ctx.val));
            let child_ctx = ctx.values_entry(&key);
            let mut inner_ctx = child_ctx.clone();
            inner_ctx.val = "val".to_string();
            emit_node(w, schema, &inner_ctx, None);
            w.close("end");
            w.close_open("else");
            w.line(&ctx.push_error("/values"));
            w.close("end");
        }

        Node::Properties {
            required,
            optional,
            additional,
        } => {
            let guard_suffix = if !required.is_empty() {
                "/properties"
            } else {
                "/optionalProperties"
            };

            // Lua table check. Also ensure it's not an array?
            // Strict JTD properties requires an object. In Lua, everything is a table.
            // dkjson decodes [] as empty table and {} as empty table.
            // We'll just check type == table.
            w.open(&format!("if is_object({}) then", ctx.val));

            for (key, node) in required {
                w.open(&format!(
                    "if {}[\"{}\"] == nil then",
                    ctx.val,
                    escape_lua(key)
                ));
                w.line(&ctx.push_error(&format!("/properties/{}", escape_lua(key))));
                w.close_open("else");
                let child_ctx = ctx.required_prop(key);
                emit_node(w, node, &child_ctx, None);
                w.close("end");
            }

            for (key, node) in optional {
                w.open(&format!(
                    "if {}[\"{}\"] ~= nil and {}[\"{}\"] ~= dkjson.null then",
                    ctx.val,
                    escape_lua(key),
                    ctx.val,
                    escape_lua(key)
                ));
                let child_ctx = ctx.optional_prop(key);
                emit_node(w, node, &child_ctx, None);
                w.close("end");
            }

            if !*additional {
                let k = ctx.key_var();
                w.open(&format!("for {} in pairs({}) do", k, ctx.val));

                let mut known: Vec<String> = Vec::new();
                if let Some(tag) = discrim_tag {
                    known.push(tag.to_string());
                }
                for key in required.keys() {
                    known.push(key.clone());
                }
                for key in optional.keys() {
                    known.push(key.clone());
                }

                if known.is_empty() {
                    w.line(&ctx.push_error_dynamic(&format!("\"/\" .. {}", k), ""));
                } else {
                    let conds: Vec<String> = known
                        .iter()
                        .map(|key| format!("{} ~= \"{}\"", k, escape_lua(key)))
                        .collect();
                    w.open(&format!("if {} then", conds.join(" and ")));
                    w.line(&ctx.push_error_dynamic(&format!("\"/\" .. {}", k), ""));
                    w.close("end");
                }
                w.close("end"); // for
            }

            w.close_open("else");
            w.line(&ctx.push_error(guard_suffix));
            w.close("end");
        }

        Node::Discriminator { tag, mapping } => {
            w.open(&format!("if is_object({}) then", ctx.val));
            w.open(&format!(
                "if {}[\"{}\"] ~= nil then",
                ctx.val,
                escape_lua(tag)
            ));
            w.open(&format!(
                "if type({}) == \"string\" then",
                ctx.required_prop(tag).val
            )); // Access prop via ctx helper or manual

            // In Lua we can't switch/match. Use if/elseif.
            let mut first = true;
            for (variant_key, variant_node) in mapping {
                if first {
                    w.open(&format!(
                        "if {}[\"{}\"] == \"{}\" then",
                        ctx.val,
                        escape_lua(tag),
                        escape_lua(variant_key)
                    ));
                    first = false;
                } else {
                    w.close_open(&format!(
                        "elseif {}[\"{}\"] == \"{}\" then",
                        ctx.val,
                        escape_lua(tag),
                        escape_lua(variant_key)
                    ));
                }
                let variant_ctx = ctx.discrim_variant(variant_key);
                emit_node(w, variant_node, &variant_ctx, Some(tag));
            }
            if !first {
                w.close_open("else");
                // Unknown tag value
                w.line(&ctx.push_error_at(&format!("/{}", escape_lua(tag)), "/mapping"));
                w.close("end");
            } else {
                // Empty mapping? JTD spec says mapping can't be empty technically but handle it.
            }

            w.close_open("else");
            // Tag not string
            w.line(&ctx.push_error_at(&format!("/{}", escape_lua(tag)), "/discriminator"));
            w.close("end");

            w.close_open("else");
            // Tag missing
            w.line(&ctx.push_error("/discriminator"));
            w.close("end");

            w.close_open("else");
            // Not object
            w.line(&ctx.push_error("/discriminator"));
            w.close("end");
        }
    }
}

fn emit_type(w: &mut CodeWriter, ctx: &EmitContext, type_kw: TypeKeyword) {
    match type_kw {
        TypeKeyword::Boolean => {
            w.open(&format!("if type({}) ~= \"boolean\" then", ctx.val));
            w.line(&ctx.push_error("/type"));
            w.close("end");
        }
        TypeKeyword::String => {
            w.open(&format!("if type({}) ~= \"string\" then", ctx.val));
            w.line(&ctx.push_error("/type"));
            w.close("end");
        }
        TypeKeyword::Timestamp => {
            w.open(&format!("if not is_rfc3339({}) then", ctx.val));
            w.line(&ctx.push_error("/type"));
            w.close("end");
        }
        TypeKeyword::Float32 | TypeKeyword::Float64 => {
            w.open(&format!("if type({}) ~= \"number\" then", ctx.val));
            w.line(&ctx.push_error("/type"));
            w.close("end");
        }
        TypeKeyword::Int8 => {
            w.open(&format!(
                "if not is_integer({}) or {} < -128 or {} > 127 then",
                ctx.val, ctx.val, ctx.val
            ));
            w.line(&ctx.push_error("/type"));
            w.close("end");
        }
        TypeKeyword::Uint8 => {
            w.open(&format!(
                "if not is_integer({}) or {} < 0 or {} > 255 then",
                ctx.val, ctx.val, ctx.val
            ));
            w.line(&ctx.push_error("/type"));
            w.close("end");
        }
        TypeKeyword::Int16 => {
            w.open(&format!(
                "if not is_integer({}) or {} < -32768 or {} > 32767 then",
                ctx.val, ctx.val, ctx.val
            ));
            w.line(&ctx.push_error("/type"));
            w.close("end");
        }
        TypeKeyword::Uint16 => {
            w.open(&format!(
                "if not is_integer({}) or {} < 0 or {} > 65535 then",
                ctx.val, ctx.val, ctx.val
            ));
            w.line(&ctx.push_error("/type"));
            w.close("end");
        }
        TypeKeyword::Int32 => {
            w.open(&format!(
                "if not is_integer({}) or {} < -2147483648 or {} > 2147483647 then",
                ctx.val, ctx.val, ctx.val
            ));
            w.line(&ctx.push_error("/type"));
            w.close("end");
        }
        TypeKeyword::Uint32 => {
            // Note: Lua numbers are doubles (53-bit mantissa). uint32 fits safely.
            w.open(&format!(
                "if not is_integer({}) or {} < 0 or {} > 4294967295 then",
                ctx.val, ctx.val, ctx.val
            ));
            w.line(&ctx.push_error("/type"));
            w.close("end");
        }
    }
}
